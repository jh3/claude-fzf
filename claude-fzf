#!/usr/bin/env bash
#
# claude-fzf - Fuzzy search and resume Claude Code sessions
#
# Usage: claude-fzf [options]
#
# Options:
#   -h, --help     Show this help message
#   -p, --preview  Preview mode only (don't resume, just print session ID)
#

set -euo pipefail

CLAUDE_PROJECTS_DIR="${HOME}/.claude/projects"
CACHE_DIR="${HOME}/.cache/claude-fzf"
CACHE_FILE="${CACHE_DIR}/sessions.cache"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

show_help() {
    cat << 'EOF'
claude-fzf - Fuzzy search and resume Claude Code sessions

Usage: claude-fzf [options]

Options:
  -h, --help     Show this help message
  -p, --preview  Preview mode only (don't resume, just print session ID)

Keybindings in FZF:
  Enter          Resume the selected session
  Ctrl-Y         Copy session ID to clipboard
  Ctrl-P         Toggle preview window
  Ctrl-D         Delete session (with confirmation)

Environment variables:
  CLAUDE_FZF_OPTS   Additional options to pass to fzf
EOF
}

# Get file modification time as epoch seconds (for cache comparison)
get_file_mtime() {
    local file="$1"
    if [[ "$OSTYPE" == "darwin"* ]]; then
        stat -f "%m" "$file" 2>/dev/null || echo "0"
    else
        stat -c "%Y" "$file" 2>/dev/null || echo "0"
    fi
}

# Extract session info from a JSONL file
# Output: session_id|timestamp|project_path|summary
extract_session_info() {
    local file="$1"
    local session_id
    local timestamp
    local project_path
    local summary
    local first_message

    # Get session ID from filename
    session_id=$(basename "$file" .jsonl)

    # Skip agent sessions (they have a different format)
    if [[ "$session_id" == agent-* ]]; then
        return
    fi

    # Extract the actual cwd from the session file (more reliable than decoding dir name)
    project_path=$(grep -m1 '"cwd"' "$file" 2>/dev/null | jq -r '.cwd // empty' 2>/dev/null || echo "")

    # Get file modification time as timestamp
    if [[ "$OSTYPE" == "darwin"* ]]; then
        timestamp=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$file" 2>/dev/null || echo "unknown")
    else
        timestamp=$(stat -c "%y" "$file" 2>/dev/null | cut -d'.' -f1 || echo "unknown")
    fi

    # Extract summary from the JSONL (look for type: "summary")
    summary=$(grep -m1 '"type":"summary"' "$file" 2>/dev/null | jq -r '.summary // empty' 2>/dev/null || echo "")

    # If no summary, try to get first user message
    if [[ -z "$summary" ]]; then
        first_message=$(grep -m1 '"type":"user"' "$file" 2>/dev/null | jq -r '.message.content // empty' 2>/dev/null | head -c 80 || echo "")
        if [[ -n "$first_message" ]]; then
            summary="$first_message"
        else
            summary="(no summary)"
        fi
    fi

    # Truncate summary if too long
    if [[ ${#summary} -gt 60 ]]; then
        summary="${summary:0:57}..."
    fi

    # Output formatted line
    echo "${session_id}|${timestamp}|${project_path}|${summary}"
}

# Lookup cached entry for a file (returns "mtime<TAB>info" or empty)
lookup_cache() {
    local file="$1"
    if [[ -f "$CACHE_FILE" ]]; then
        grep -F "$file"$'\t' "$CACHE_FILE" 2>/dev/null | head -1 | cut -f2-
    fi
}

# Generate the list of all sessions for FZF (with caching)
generate_session_list() {
    # Ensure cache directory exists
    mkdir -p "$CACHE_DIR"

    # Temporary file for new cache
    local new_cache
    new_cache=$(mktemp)

    # Collect output for sorting
    local output=""

    # Process all session files (use process substitution to avoid subshell)
    while read -r file; do
        # Skip agent sessions
        local session_id
        session_id=$(basename "$file" .jsonl)
        if [[ "$session_id" == agent-* ]]; then
            continue
        fi

        local current_mtime
        current_mtime=$(get_file_mtime "$file")

        local session_info=""
        local cached_entry
        cached_entry=$(lookup_cache "$file")

        if [[ -n "$cached_entry" ]]; then
            # Check if cached mtime matches
            local cached_mtime cached_info
            cached_mtime="${cached_entry%%$'\t'*}"
            cached_info="${cached_entry#*$'\t'}"

            if [[ "$cached_mtime" == "$current_mtime" ]]; then
                # Use cached data
                session_info="$cached_info"
            else
                # File changed, re-extract
                session_info=$(extract_session_info "$file")
            fi
        else
            # New file, extract info
            session_info=$(extract_session_info "$file")
        fi

        # Collect session info and update cache
        if [[ -n "$session_info" ]]; then
            output+="${session_info}"$'\n'
            printf '%s\t%s\t%s\n' "$file" "$current_mtime" "$session_info" >> "$new_cache"
        fi
    done < <(find "$CLAUDE_PROJECTS_DIR" -maxdepth 2 -name "*.jsonl" -type f 2>/dev/null)

    # Update cache file
    mv "$new_cache" "$CACHE_FILE" 2>/dev/null || true

    # Output sorted results
    echo -n "$output" | sort -t'|' -k2 -r
}

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Source tmux integration helpers
source "${SCRIPT_DIR}/claude-fzf-tmux"

main() {
    local preview_only=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            -p|--preview)
                preview_only=true
                shift
                ;;
            *)
                echo "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done

    # Check if claude projects directory exists
    if [[ ! -d "$CLAUDE_PROJECTS_DIR" ]]; then
        echo "Error: Claude projects directory not found: $CLAUDE_PROJECTS_DIR"
        exit 1
    fi

    # Check if fzf is installed
    if ! command -v fzf &> /dev/null; then
        echo "Error: fzf is required but not installed."
        echo "Install with: brew install fzf"
        exit 1
    fi

    # Generate list and run fzf
    local selected
    selected=$(generate_session_list | fzf \
        --ansi \
        --delimiter='|' \
        --with-nth=2,3,4 \
        --preview="${SCRIPT_DIR}/claude-fzf-preview {1}" \
        --preview-window='right:50%:wrap' \
        --header='Enter: Resume | Ctrl-Y: Copy ID | Ctrl-P: Toggle preview' \
        --bind='ctrl-p:toggle-preview' \
        --bind='ctrl-y:execute-silent(echo -n {1} | pbcopy)+abort' \
        --height='80%' \
        --layout=reverse \
        --prompt='Claude Sessions > ' \
        ${CLAUDE_FZF_OPTS:-} \
    ) || true

    if [[ -z "$selected" ]]; then
        exit 0
    fi

    # Extract session ID (first field) and project path (third field)
    local session_id
    local project_path
    session_id=$(echo "$selected" | cut -d'|' -f1)
    project_path=$(echo "$selected" | cut -d'|' -f3)

    if $preview_only; then
        # Output both path and session ID for shell integration
        echo "${project_path}|${session_id}"
    else
        # Check if we're in tmux and should use session management
        if is_in_tmux; then
            local session_name
            session_name=$(project_to_session_name "$project_path")

            if session_exists "$session_name"; then
                # Session exists - switch to it and resume claude in the claude window
                switch_to_session "$session_name"
                run_in_window "$session_name" "claude" "claude --resume $session_id"
            else
                # Create new session with 4-window layout
                create_project_session "$session_name" "$project_path"
                switch_to_session "$session_name"
                run_in_window "$session_name" "claude" "claude --resume $session_id"
            fi
        else
            # Not in tmux - use original behavior
            if [[ -d "$project_path" ]]; then
                cd "$project_path"
                exec claude --resume "$session_id"
            else
                echo "Warning: Project directory not found: $project_path"
                echo "Attempting to resume anyway..."
                exec claude --resume "$session_id"
            fi
        fi
    fi
}

main "$@"
