package tmux

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/GianlucaP106/gotmux/gotmux"
	"github.com/jh3/claude-fzf/internal/config"
)

// runTmux runs a tmux command directly (bypasses gotmux for reliability)
func runTmux(args ...string) error {
	cmd := exec.Command("tmux", args...)
	out, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("%w: %s", err, string(out))
	}
	return nil
}

// Manager handles tmux operations
type Manager struct {
	tmux *gotmux.Tmux
}

// New creates a tmux manager
func New() (*Manager, error) {
	t, err := gotmux.DefaultTmux()
	if err != nil {
		return nil, err
	}
	return &Manager{tmux: t}, nil
}

// IsInsideTmux checks if we're running inside tmux
func IsInsideTmux() bool {
	return os.Getenv("TMUX") != ""
}

// SessionExists checks if a tmux session exists
func (m *Manager) SessionExists(name string) bool {
	return m.tmux.HasSession(name)
}

// CurrentSession returns the current tmux session name and window count
func (m *Manager) CurrentSession() (name string, windowCount int, err error) {
	// Get current session name
	output, err := m.tmux.Command("display-message", "-p", "#{session_name}")
	if err != nil {
		return "", 0, err
	}
	name = strings.TrimSpace(output)

	// Get window count
	output, err = m.tmux.Command("display-message", "-p", "#{session_windows}")
	if err != nil {
		return "", 0, err
	}
	windowCount, _ = strconv.Atoi(strings.TrimSpace(output))

	return name, windowCount, nil
}

// IsDisposableSession checks if the current session is a "scratch" session
// (numeric name with 1-2 windows) that can be repurposed.
// We allow 2 windows because claude-fzf itself may be running in a new window.
func (m *Manager) IsDisposableSession() (bool, string) {
	name, windowCount, err := m.CurrentSession()
	if err != nil {
		return false, ""
	}

	// Check if name is numeric (auto-generated by tmux)
	if _, err := strconv.Atoi(name); err != nil {
		return false, ""
	}

	// Check if it has 1-2 windows (original shell + possibly claude-fzf window)
	if windowCount > 2 {
		return false, ""
	}

	return true, name
}

// RepurposeCurrentSession renames the current session and adds project windows
// Uses direct exec.Command for reliability
func (m *Manager) RepurposeCurrentSession(newName, projectPath string, windows []config.Window) error {
	if len(windows) == 0 {
		return fmt.Errorf("no windows configured")
	}

	currentName, _, err := m.CurrentSession()
	if err != nil {
		return fmt.Errorf("failed to get current session: %w", err)
	}

	// Rename the session
	if err := runTmux("rename-session", "-t", currentName, newName); err != nil {
		return fmt.Errorf("failed to rename session: %w", err)
	}

	// Get current window name (claude-fzf is running here)
	cmd := exec.Command("tmux", "display-message", "-p", "#{window_name}")
	out, _ := cmd.Output()
	currentWindowName := strings.TrimSpace(string(out))

	// List existing windows
	cmd = exec.Command("tmux", "list-windows", "-t", newName, "-F", "#{window_name}")
	out, err = cmd.Output()
	if err != nil {
		return fmt.Errorf("failed to list windows: %w", err)
	}

	existingWindows := strings.Split(strings.TrimSpace(string(out)), "\n")
	if len(existingWindows) == 0 {
		return fmt.Errorf("no windows in session")
	}

	// Find a window to rename to "claude" - prefer one that's not the current window
	windowToRename := ""
	for _, w := range existingWindows {
		if w != currentWindowName && w != "" {
			windowToRename = w
			break
		}
	}
	if windowToRename == "" {
		windowToRename = existingWindows[0]
	}

	// Rename the window to "claude"
	if err := runTmux("rename-window", "-t", newName+":"+windowToRename, "claude"); err != nil {
		return fmt.Errorf("failed to rename window to claude: %w", err)
	}

	// Add the additional windows (use -a to append, avoiding index conflicts)
	for _, winCfg := range windows {
		if err := runTmux("new-window", "-a", "-t", newName+":", "-n", winCfg.Name, "-c", projectPath); err != nil {
			return fmt.Errorf("failed to create window %q: %w", winCfg.Name, err)
		}
		if winCfg.Command != "" {
			m.runWindowCommand(newName, winCfg.Name, winCfg.Command)
		}
	}

	// Select the claude window
	runTmux("select-window", "-t", newName+":claude")

	return nil
}

// CreateProjectSession creates a new tmux session with configured windows
// Uses direct exec.Command for reliability when running from within tmux
func (m *Manager) CreateProjectSession(name, projectPath, shellCommand string, windows []config.Window) error {
	if len(windows) == 0 {
		return fmt.Errorf("no windows configured")
	}

	// Create detached session with first window named "claude"
	if err := runTmux("new-session", "-d", "-s", name, "-n", "claude", "-c", projectPath); err != nil {
		return fmt.Errorf("failed to create session: %w", err)
	}

	// Create additional windows (use -a to append, avoiding index conflicts)
	for _, winCfg := range windows {
		if err := runTmux("new-window", "-a", "-t", name+":", "-n", winCfg.Name, "-c", projectPath); err != nil {
			return fmt.Errorf("failed to create window %q: %w", winCfg.Name, err)
		}
		if winCfg.Command != "" {
			m.runWindowCommand(name, winCfg.Name, winCfg.Command)
		}
	}

	// Select the claude window
	runTmux("select-window", "-t", name+":claude")

	return nil
}

// SwitchToSession switches the client to a session
func (m *Manager) SwitchToSession(name string) error {
	return m.tmux.SwitchClient(&gotmux.SwitchClientOptions{
		TargetSession: name,
	})
}

// EnsureSessionWindows ensures a session has the claude window and configured windows
// Creates any missing windows. Returns true if claude window was created (needs command).
func (m *Manager) EnsureSessionWindows(name, projectPath string, windows []config.Window) (claudeCreated bool, err error) {
	// Get current windows in session using exec.Command for reliability
	cmd := exec.Command("tmux", "list-windows", "-t", name, "-F", "#{window_name}")
	out, err := cmd.Output()
	if err != nil {
		return false, fmt.Errorf("failed to list windows: %w", err)
	}
	output := string(out)

	existing := make(map[string]bool)
	for _, line := range strings.Split(strings.TrimSpace(output), "\n") {
		if line != "" {
			existing[line] = true
		}
	}

	// Ensure claude window exists
	if !existing["claude"] {
		if err := runTmux("new-window", "-a", "-t", name+":", "-n", "claude", "-c", projectPath); err != nil {
			return false, fmt.Errorf("failed to create claude window: %w", err)
		}
		claudeCreated = true
	}

	// Ensure configured windows exist (use -a to append, avoiding index conflicts)
	for _, winCfg := range windows {
		if !existing[winCfg.Name] {
			if err := runTmux("new-window", "-a", "-t", name+":", "-n", winCfg.Name, "-c", projectPath); err != nil {
				return claudeCreated, fmt.Errorf("failed to create window %q: %w", winCfg.Name, err)
			}
			if winCfg.Command != "" {
				m.runWindowCommand(name, winCfg.Name, winCfg.Command)
			}
		}
	}

	return claudeCreated, nil
}

// runWindowCommand runs a command in a window, keeping the shell alive after
func (m *Manager) runWindowCommand(sessionName, windowName, command string) {
	if command == "" {
		return
	}
	target := fmt.Sprintf("%s:%s", sessionName, windowName)
	escaped := strings.ReplaceAll(command, "'", "'\\''")
	wrapped := fmt.Sprintf("sh -c '%s; exec \"$SHELL\"'", escaped)
	m.tmux.Command("respawn-pane", "-k", "-t", target, wrapped)
}

// RespawnWindow kills the current process in a window and runs a new command
// This runs the command directly without visible typing
func (m *Manager) RespawnWindow(sessionName, windowName, command string) error {
	target := fmt.Sprintf("%s:%s", sessionName, windowName)
	_, err := m.tmux.Command("respawn-pane", "-k", "-t", target, command)
	return err
}

// SelectWindow selects a specific window in a session
func (m *Manager) SelectWindow(sessionName, windowName string) error {
	target := fmt.Sprintf("%s:%s", sessionName, windowName)
	_, err := m.tmux.Command("select-window", "-t", target)
	return err
}

// ProjectToSessionName converts a project path to a session name
func ProjectToSessionName(projectPath string) string {
	name := filepath.Base(projectPath)
	if name == "" || name == "." {
		return "claude"
	}
	return name
}
