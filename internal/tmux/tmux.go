package tmux

import (
	"fmt"
	"os"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/GianlucaP106/gotmux/gotmux"
	"github.com/jh3/claude-fzf/internal/config"
)

// Manager handles tmux operations
type Manager struct {
	tmux *gotmux.Tmux
}

// New creates a tmux manager
func New() (*Manager, error) {
	t, err := gotmux.DefaultTmux()
	if err != nil {
		return nil, err
	}
	return &Manager{tmux: t}, nil
}

// IsInsideTmux checks if we're running inside tmux
func IsInsideTmux() bool {
	return os.Getenv("TMUX") != ""
}

// SessionExists checks if a tmux session exists
func (m *Manager) SessionExists(name string) bool {
	return m.tmux.HasSession(name)
}

// CurrentSession returns the current tmux session name and window count
func (m *Manager) CurrentSession() (name string, windowCount int, err error) {
	// Get current session name
	output, err := m.tmux.Command("display-message", "-p", "#{session_name}")
	if err != nil {
		return "", 0, err
	}
	name = strings.TrimSpace(output)

	// Get window count
	output, err = m.tmux.Command("display-message", "-p", "#{session_windows}")
	if err != nil {
		return "", 0, err
	}
	windowCount, _ = strconv.Atoi(strings.TrimSpace(output))

	return name, windowCount, nil
}

// IsDisposableSession checks if the current session is a "scratch" session
// (numeric name with 1-2 windows) that can be repurposed.
// We allow 2 windows because claude-fzf itself may be running in a new window.
func (m *Manager) IsDisposableSession() (bool, string) {
	name, windowCount, err := m.CurrentSession()
	if err != nil {
		return false, ""
	}

	// Check if name is numeric (auto-generated by tmux)
	if _, err := strconv.Atoi(name); err != nil {
		return false, ""
	}

	// Check if it has 1-2 windows (original shell + possibly claude-fzf window)
	if windowCount > 2 {
		return false, ""
	}

	return true, name
}

// RepurposeCurrentSession renames the current session and adds project windows
func (m *Manager) RepurposeCurrentSession(newName, projectPath string, windows []config.Window) error {
	if len(windows) == 0 {
		return fmt.Errorf("no windows configured")
	}

	currentName, _, err := m.CurrentSession()
	if err != nil {
		return fmt.Errorf("failed to get current session: %w", err)
	}

	// Rename the session
	_, err = m.tmux.Command("rename-session", "-t", currentName, newName)
	if err != nil {
		return fmt.Errorf("failed to rename session: %w", err)
	}

	// Get the session
	sess, err := m.tmux.GetSessionByName(newName)
	if err != nil {
		return fmt.Errorf("failed to get renamed session: %w", err)
	}

	// Find a window to rename to "claude" - prefer one that's not the current window
	existingWindows, err := sess.ListWindows()
	if err != nil {
		return fmt.Errorf("failed to list windows: %w", err)
	}
	if len(existingWindows) == 0 {
		return fmt.Errorf("no windows in session")
	}

	// Get the current window name so we can avoid it
	currentWindowOutput, _ := m.tmux.Command("display-message", "-p", "#{window_name}")
	currentWindowName := strings.TrimSpace(currentWindowOutput)

	// Find a window that's not the current one (claude-fzf is likely running there)
	var windowToRename *gotmux.Window
	for i := range existingWindows {
		if existingWindows[i].Name != currentWindowName {
			windowToRename = existingWindows[i]
			break
		}
	}
	// Fallback to first window if all else fails
	if windowToRename == nil {
		windowToRename = existingWindows[0]
	}

	if err := windowToRename.Rename("claude"); err != nil {
		return fmt.Errorf("failed to rename window to claude: %w", err)
	}

	// Add the additional windows
	for _, winCfg := range windows {
		_, err := sess.NewWindow(&gotmux.NewWindowOptions{
			WindowName:     winCfg.Name,
			StartDirectory: projectPath,
		})
		if err != nil {
			return fmt.Errorf("failed to create window %q: %w", winCfg.Name, err)
		}

		if winCfg.Command != "" {
			target := fmt.Sprintf("%s:%s", newName, winCfg.Name)
			escaped := strings.ReplaceAll(winCfg.Command, "'", "'\\''")
			wrapped := fmt.Sprintf("sh -c '%s; exec \"$SHELL\"'", escaped)
			m.tmux.Command("respawn-pane", "-k", "-t", target, wrapped)
		}
	}

	// Select the claude window
	w, err := sess.GetWindowByName("claude")
	if err != nil {
		return fmt.Errorf("failed to get claude window: %w", err)
	}
	w.Select()

	return nil
}

// CreateProjectSession creates a new tmux session with configured windows
// If shellCommand is provided, the first window (claude) runs that command
func (m *Manager) CreateProjectSession(name, projectPath, shellCommand string, windows []config.Window) error {
	if len(windows) == 0 {
		return fmt.Errorf("no windows configured")
	}

	sess, err := m.tmux.NewSession(&gotmux.SessionOptions{
		Name:           name,
		StartDirectory: projectPath,
		ShellCommand:   shellCommand,
	})
	if err != nil {
		return fmt.Errorf("failed to create session: %w", err)
	}

	// Rename the first window to "claude"
	existingWindows, err := sess.ListWindows()
	if err == nil && len(existingWindows) > 0 {
		existingWindows[0].Rename("claude")
	}

	// Create additional windows from config
	for _, winCfg := range windows {
		_, err := sess.NewWindow(&gotmux.NewWindowOptions{
			WindowName:     winCfg.Name,
			StartDirectory: projectPath,
		})
		if err != nil {
			return fmt.Errorf("failed to create window %q: %w", winCfg.Name, err)
		}

		// Run command in window if specified (silently via respawn-pane)
		// Wrap command so shell stays alive after command exits
		if winCfg.Command != "" {
			target := fmt.Sprintf("%s:%s", name, winCfg.Name)
			escaped := strings.ReplaceAll(winCfg.Command, "'", "'\\''")
			wrapped := fmt.Sprintf("sh -c '%s; exec \"$SHELL\"'", escaped)
			m.tmux.Command("respawn-pane", "-k", "-t", target, wrapped)
		}
	}

	// Select the claude window
	w, err := sess.GetWindowByName("claude")
	if err == nil {
		w.Select()
	}

	return nil
}

// SwitchToSession switches the client to a session
func (m *Manager) SwitchToSession(name string) error {
	return m.tmux.SwitchClient(&gotmux.SwitchClientOptions{
		TargetSession: name,
	})
}

// SendKeysToWindow sends keys to a specific window and executes them
func (m *Manager) SendKeysToWindow(sessionName, windowName, keys string) error {
	sess, err := m.tmux.GetSessionByName(sessionName)
	if err != nil {
		return err
	}

	w, err := sess.GetWindowByName(windowName)
	if err != nil {
		return fmt.Errorf("window not found: %s", windowName)
	}

	panes, err := w.ListPanes()
	if err != nil || len(panes) == 0 {
		return fmt.Errorf("no panes in window: %s", windowName)
	}

	pane := panes[0]
	if err := pane.SendKeys(keys); err != nil {
		return err
	}
	return pane.SendKeys("Enter")
}

// RespawnWindow kills the current process in a window and runs a new command
// This runs the command directly without visible typing
func (m *Manager) RespawnWindow(sessionName, windowName, command string) error {
	target := fmt.Sprintf("%s:%s", sessionName, windowName)
	_, err := m.tmux.Command("respawn-pane", "-k", "-t", target, command)
	return err
}

// SelectWindow selects a specific window in a session
func (m *Manager) SelectWindow(sessionName, windowName string) error {
	target := fmt.Sprintf("%s:%s", sessionName, windowName)
	_, err := m.tmux.Command("select-window", "-t", target)
	return err
}

// ProjectToSessionName converts a project path to a session name
func ProjectToSessionName(projectPath string) string {
	name := filepath.Base(projectPath)
	if name == "" || name == "." {
		return "claude"
	}
	return name
}
